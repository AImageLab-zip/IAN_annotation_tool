import numpy as np
import viewer
import cv2
import imageio


def x_slice(volume, fixed_val):
    """
    create a lateral 2D projection for the
    :param volume: 3D numpy volume
    :param fixed_val: fixed coord over the X
    :return: 2D numpy image
    """
    return np.squeeze(volume[:, :, fixed_val])


def y_slice(volume, fixed_val):
    """
    create a front 2D projection for the
    :param volume:
    :param fixed_val:
    :return:
    """
    return np.squeeze(volume[:, fixed_val, :])


def quantiles(volume, min=0.02, max=0.98):
    min = np.quantile(volume, min),
    max = np.quantile(volume, max)
    volume[volume > max] = max
    volume[volume < min] = min
    return volume


def generate_side_coords(h_offset, l_offset, derivative, offset=100):
    """
    creating the set of perpendicular points from the curve generated by coords
    :param h_offset: high offset points from the reference curve
    :param l_offset: low offset points from the reference curve
    :param derivative: derivative of the function which generated coords (for each point in coords)
    :return: a set of (y,x) coords for each line. return type is a list of lists of tuple
    """
    slices = []
    for (x1, y1), (x2, y2), alfa in zip(h_offset, l_offset, derivative):
        sign = 1 if alfa > 0 else -1
        x_step = abs(x1 - x2) / offset
        y_step = abs(y1 - y2) / offset
        points = [
            [(x1 + sign * i * x_step), (y1 + (i * y_step))] for i in
            range(offset + 1)
        ]
        slices.append(points)
    return slices


def canal_slice(volume, side_coords, interpolation='bicubic'):
    """
    :param volume: 3D numpy matrix
    :param side_coords: list of lists of tuple, each element of the list is a list of y-x coordinates describing a slice
    :param interpolation: type of interpolation: bilinear or nearest are implemented
    :return: a volume representing all the cuts generated from side_coords on volume
    """

    if interpolation == 'bilinear':
        interp_fn = simple_interpolation
    elif interpolation == 'bicubic':
        interp_fn = bicubic_interpolation
    else:
        interp_fn = lambda x, y, vol: vol[:, int(y), int(x)]  # nearest

    h = volume.shape[0]
    w = max([len(points) for points in side_coords])
    z = len(side_coords)
    if len(volume.shape) == 3:
        cut = np.zeros((z, h, w), np.float32)
        for z_id, points in enumerate(side_coords):
            for w_id, (x, y) in enumerate(points):
                # avoiding overflow
                if (x - 2) < 0 or (y - 2) < 0 or (x + 2) >= volume.shape[2] or (y + 2) >= volume.shape[1]:
                    cut[z_id, :, w_id] = np.zeros(shape=volume.shape[0])  # fill the array with zeros
                else:
                    cut[z_id, :, w_id] = interp_fn(x, y, volume)  # bilinear interpolation
    elif len(volume.shape) == 4:
        cut = np.zeros((z, h, w, 3), np.float32)
        for z_id, points in enumerate(side_coords):
            for w_id, (x, y) in enumerate(points):
                # avoiding overflow
                if (x - 2) < 0 or (y - 2) < 0 or (x + 2) >= volume.shape[2] or (y + 2) >= volume.shape[1]:
                    cut[z_id, :, w_id, :] = np.zeros(shape=(volume.shape[0], 3))  # fill the array with zeros
                else:
                    cut[z_id, :, w_id, :] = interp_fn(x, y, volume)  # bilinear interpolation
    else:
        raise Exception("weird volume shape")

    # fixing possible overflows
    cut[cut > 1] = 1
    cut[cut < 0] = 0
    return cut


def recap_on_gif(coords, high_offset, low_offset, side_volume, side_coords, slice, gt_side_volume):
    """
    create a gif recap where a panoramic of the cross cuts is visible along with the section and the ground truth
    :param coords: set of coords of the dental line (for drawing)
    :param high_offset: set of coords of the first offset from coords (for drawing)
    :param low_offset: set of coords of the second offset from coords (for drawing)
    :param side_volume: 3D volume of the cuts
    :param side_coords: coords of the lines we used to cut and generate side_volume
    :param slice: 2D image where coords and offsets are drawn
    :param gt_side_volume: RGB 4D volume, same of side_volume but with annotations
    :return: a gif
    """

    slice = cv2.normalize(slice, slice, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
    original = np.tile(slice, (3, 1, 1))  # overlay on the original image (colorful)
    original = np.moveaxis(original, 0, -1)

    # drawing the line and the offsets of the upper view
    for idx in range(len(coords)):
        original[int(coords[idx][1]), int(coords[idx][0])] = (255, 0, 0)
        try:
            original[int(high_offset[idx][1]), int(high_offset[idx][0])] = (0, 255, 0)
            original[int(low_offset[idx][1]), int(low_offset[idx][0])] = (0, 255, 0)
        except:
            continue
    # create an upper view for each section
    sections = []
    for points in side_coords:
        tmp = original.copy()
        for x, y in points:
            if slice.shape[1] > x > 0 and slice.shape[0] > y > 0:
                tmp[int(y), int(x)] = (0, 0, 255)
        sections.append(tmp)
    sections = np.stack(sections)

    # rescaling the projection volume properly
    y_ratio = original.shape[0] / side_volume.shape[1]
    width = int(side_volume.shape[2] * y_ratio)
    height = int(side_volume.shape[1] * y_ratio)
    scaled_side_volume = np.ndarray(shape=(side_volume.shape[0], height, width))
    scaled_gt_volume = np.ndarray(shape=(gt_side_volume.shape[0], height, width, 3))
    for i in range(side_volume.shape[0]):
        scaled_side_volume[i] = cv2.resize(side_volume[i, :, :], (width, height), interpolation=cv2.INTER_AREA)
        scaled_gt_volume[i] = cv2.resize(gt_side_volume[i, :, :], (width, height), interpolation=cv2.INTER_AREA)

    # padding the side volume and rescaling
    # pad_side_volume = np.zeros((side_volume.shape[0], original.shape[0], original.shape[1]))
    # pad_side_volume[:, :side_volume.shape[1], :side_volume.shape[2]] = side_volume
    scaled_side_volume = cv2.normalize(scaled_side_volume, scaled_side_volume, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
    scaled_gt_volume = cv2.normalize(scaled_gt_volume, scaled_gt_volume, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)

    # creating RGB volume
    scaled_side_volume = np.tile(scaled_side_volume, (3, 1, 1, 1))  # overlay on the original image (colorful)
    scaled_side_volume = np.moveaxis(scaled_side_volume, 0, -1)

    # GIF creation
    gif_source = np.concatenate((sections, scaled_side_volume, scaled_gt_volume), axis=2)
    gif = []
    for i in range(gif_source.shape[0]):
        gif.append(gif_source[i, :, :])
    imageio.mimsave('test.gif', gif)


def get_annotations(metadata):
    """
    return a mask which maps on each pixel of the input image a ground truth value 0 or 1
    :param metadata: metadata for a given slice
    :return: mask extracted from the metadata
    """
    return metadata.overlay_array(0x6004)


def get_annotated_volume(metadata):
    """
    return a volume of masks according to the overlays fields
    :param metadata: volume of metadata
    :return: a binary volume
    """
    annotations = []
    try:
        for meta in metadata:
            annotations.append(get_annotations(meta))
        return np.stack(annotations).astype(np.bool_)
    except:
        print("WARNING: NO ANNOTATION FOUND ON THE CURRENT VOLUME! BLACK MASK RETURNED")
        return np.empty(shape=1)


def simple_normalization(data):
    """
    normalize slice or volumes between 0 and 1
    :param data: numpy image or volume
    :return: numpy normalized image
    """
    return data.astype(np.float32)/data.max()


def simple_interpolation(x_func, y_func, volume):
    """
    simple interpolation between four pixels of the image given a float set of coords
    :param x_func: float x coord
    :param y_func: float y coord on the spline
    :param volume: 3D volume of the dental image
    :return: a numpy array over the Z axis of the volume on a fixed (x,y) obtained by interpolation
    """
    x1, x2 = int(np.floor(x_func)), int(np.floor(x_func) + 1)
    y1, y2 = int(np.floor(y_func)), int(np.floor(y_func) + 1)
    dx, dy = x_func - x1, y_func - y1
    P1 = volume[:, y1, x1] * (1 - dx) * (1 - dy)
    P2 = volume[:, y2, x1] * (1 - dx) * dy
    P3 = volume[:, y1, x2] * dx * (1 - dy)
    P4 = volume[:, y2, x2] * dx * dy
    return P1 + P2 + P3 + P4


def cubic_interpolation(p0, p1, p2, p3, coord):
    """
    cubic interpolation according to https://www.paulinternet.nl/?page=bicubic
    coord must be rescaled between 0 and 1. we use the floating part between the coords for p1 and p2
    :param p0: column of values for coord x0
    :param p1: column of values for coord x1
    :param p2: column of values for coord x2
    :param p3: column of values for coord x3
    :param coord: coordinate to interpolate on
    :return: cubic interpolated value
    """
    if coord == 0:
        return p1  # if we already have an int coord we don't need to interpolate this stripe
    return p1 + 0.5 * coord * (p2 - p0 + coord * (2 * p0 - 5 * p1 + 4 * p2 - p3 + coord * (3. * (p1 - p2) + p3 - p0)))


def bicubic_interpolation(x_func, y_func, volume):
    """
    perform bicubic interpolation by firstly first interpolating
    the four columns and then interpolating the results in the y direction
    :param x_func: x coord to interpolate on
    :param y_func: y coord to interpolate on
    :param volume: tridimensional volume
    :return: all the interpolated values on a z column
    """
    x0, x1, x2, x3 = int(np.floor(x_func)) - 1, int(np.floor(x_func)), int(np.ceil(x_func)), int(np.ceil(x_func)) + 1
    y0, y1, y2, y3 = int(np.floor(y_func)) -1, int(np.floor(y_func)), int(np.ceil(y_func)), int(np.ceil(y_func)) + 1
    i0 = cubic_interpolation(volume[:, y0, x0], volume[:, y0, x1],  volume[:, y0, x2],  volume[:, y0, x3], x_func - int(x_func))
    i1 = cubic_interpolation(volume[:, y1, x0], volume[:, y1, x1],  volume[:, y1, x2],  volume[:, y1, x3], x_func - int(x_func))
    i2 = cubic_interpolation(volume[:, y2, x0], volume[:, y2, x1],  volume[:, y2, x2],  volume[:, y2, x3], x_func - int(x_func))
    i3 = cubic_interpolation(volume[:, y3, x0], volume[:, y3, x1],  volume[:, y3, x2],  volume[:, y3, x3], x_func - int(x_func))
    return cubic_interpolation(i0, i1, i2, i3, y_func - int(y_func))


def compute_skeleton(img):
    """
    create the skeleton using morphology
    :param img: source image
    :return: image with the same input shape, b&w: 0 background, 255 skeleton elements
    """
    img = img.astype(np.uint8)
    size = img.size
    skel = np.zeros(img.shape, np.uint8)
    kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (3, 3))
    while True:
        eroded = cv2.erode(img, kernel)
        temp = cv2.dilate(eroded, kernel)
        temp = cv2.subtract(img, temp)
        skel = np.bitwise_or(skel, temp)
        img = eroded.copy()
        zeros = size - cv2.countNonZero(img)
        if zeros == size:
            return skel


def arch_detection(slice, debug=False):
    """
    compute a polynomial spline of the dental arch from a DICOM file
    :param slice: the source image
    :return: a polinomial funtion, start and end X coords from there the dental arch can be tracked
    """
    if debug:
        viewer.plot_2D(slice)
    # initial closing
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    arch = cv2.morphologyEx(slice, cv2.MORPH_CLOSE, kernel)

    # varying threashold until we white area is about 12%
    th = 0.50
    while True:
        tmp = cv2.threshold(arch, th, 1, cv2.THRESH_BINARY)[1].astype(np.uint8)
        score = tmp[tmp==1].size / tmp.size
        if debug:
            print("score for th {} is {}".format(th, score))
            viewer.plot_2D(tmp)
        if score > 0.11:
            arch = tmp
            break
        th -= .04

    # hole filling
    # kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (15, 15))
    # arch = cv2.morphologyEx(arch, cv2.MORPH_CLOSE, kernel)
    # if debug:
    #     viewer.plot_2D(arch)

    # major filtering with labelling: first remove all the little white parts
    ret, labels = cv2.connectedComponents(arch)
    sizes = np.asarray([labels[labels == label].size for label in range(1, ret)])
    labels[labels != (sizes.argmax() + 1)] = 0  # set all not maximum components to background
    labels[labels == (sizes.argmax() + 1)] = 1  # set the biggest components as foreground

    # let's now fill the rest of the holes if any
    labels = 1 - labels
    ret, labels = cv2.connectedComponents(labels.astype(np.uint8))
    sizes = np.asarray([labels[labels == label].size for label in range(1, ret)])
    labels[labels != (sizes.argmax() + 1)] = 0
    labels[labels == (sizes.argmax() + 1)] = 1
    labels = 1 - labels

    # for label in range(1, ret):
    #     if labels[labels == label].size < 10000:
    #         labels[labels == label] = 0
    if debug:
        viewer.plot_2D(labels)

    # compute skeleton
    skel = compute_skeleton(labels)
    if debug:
        viewer.plot_2D(skel)

    # # labelling on the resulting skeleton
    # cs, im = cv2.findContours(skel, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    # filtered = []
    # for c in cs:
    #     if len(c) > 40:
    #         filtered.append(c)
    #
    # # creating the mask of chosen pixels
    # contour = np.zeros(skel.shape, np.uint8)
    # cv2.drawContours(contour, filtered, -1, 255)
    # if debug:
    #     viewer.plot_2D(contour)

    # regression polynomial function
    coords = np.argwhere(skel > 0)
    y = [y for y, x in coords]
    x = [x for y, x in coords]
    pol = np.polyfit(x, y, 12)
    p = np.poly1d(pol)

    # generating the curve for a check
    if debug:
        recon = np.zeros(skel.shape, np.uint8)  # binary image for test
        original_rgb = np.tile(slice, (3, 1, 1))  # overlay on the original image (colorful)
        original_rgb = np.moveaxis(original_rgb, 0, -1)
        for sample in range(min(x), max(x)):
            y_sample = p(sample)
            recon[int(y_sample), sample] = 255
            original_rgb[int(y_sample), sample, :] = (255, 0, 0)
        viewer.plot_2D(recon)
        viewer.plot_2D(original_rgb, cmap=None)

    return p, min(x), max(x)


def arch_lines(func, start, end, offset=50):
    """
    this functions uses the first order derivative of the function func to track the proper points (x,y) from start to end.
    :param func: functions which approximate the dental curve
    :param start: first x coord
    :param end: last x coord
    :param offset: offset to generate two more curves
    :return: the curve over the dental arch and two parallel lines
    """
    d = 1
    delta = 0.3
    coords = []
    x = start + 1
    # we start from the range of X values on the X axis,
    # we create a new list X of x coords along the curve
    # we exploit the first order derivative to place values in X
    # so that f(X) is equally distant for each point in X
    while x < end:
        coords.append((x, func(x)))
        alfa = (func(x+delta/2) - func(x-delta/2)) / delta
        x = x + d * np.sqrt(1/(alfa**2 + 1))

    # creating lines parallel to the spline
    high_offset = []
    low_offset = []
    derivative = []
    for x, y in coords:
        alfa = (func(x + delta / 2) - func(x - delta / 2)) / delta  # first derivative
        alfa = -1 / alfa  # perpendicular coeff
        cos = np.sqrt(1/(alfa**2 + 1))
        sin = np.sqrt(alfa ** 2 / (alfa ** 2 + 1))
        if alfa > 0:
            low_offset.append((x + offset * cos, y + offset * sin))
            high_offset.append((x - offset * cos, y - offset * sin))
        else:
            low_offset.append((x - offset * cos, y + offset * sin))
            high_offset.append((x + offset * cos, y - offset * sin))
        derivative.append(alfa)

    return low_offset, coords, high_offset, derivative


def create_panorex(volume, coords, high_offset, low_offset):
    """
    generate three panorex, from a spline over the dental arch and two parallel lines
    :param volume: 3D volume for panorex projection
    :param coords: set of coordinated of the spline
    :param high_offset: set of coordinates from one parallel line
    :param low_offset: set of coordinates from the second parallel line
    :return: the panorex generated from coords
    """
    z_shape, y_shape, x_shape = volume.shape
    # better re-projection using bi-linear interpolation
    panorex = np.zeros((z_shape, len(coords)), np.float32)
    for idx, (x, y) in enumerate(coords):
        # panorex[:, idx] = simple_interpolation(x, y, volume)
        panorex[:, idx] = simple_interpolation(x, y, volume)

    # re-projection of the offsets curves
    panorex_up = np.zeros((z_shape, len(high_offset)), np.float32)
    panorex_down = np.zeros((z_shape, len(low_offset)), np.float32)
    for idx, (x, y) in enumerate(high_offset):
        panorex_up[:, idx] = simple_interpolation(x, y, volume)
    for idx, (x, y) in enumerate(low_offset):
        panorex_down[:, idx] = simple_interpolation(x, y, volume)

    viewer.plot_2D(panorex_down, cmap='bone')
    viewer.plot_2D(panorex, cmap='bone')
    viewer.plot_2D(panorex_up, cmap='bone')
    return panorex


def increase_contrast(image):
    sharp = image * 255  # [0 - 255]
    sharp = sharp.astype(np.uint8)
    clahe = cv2.createCLAHE(clipLimit=1.8, tileGridSize=(8, 8))
    sharp = clahe.apply(sharp)
    sharp = sharp.astype(np.float32) / 255  # back to [0-1]
    return sharp
